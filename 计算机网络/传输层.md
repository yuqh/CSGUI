## TCP

### 三次握手与四次挥手

首先给出TCP报文段

![捕获.PNG](https://i.loli.net/2019/12/19/ye6lqfZDuYJkOaS.png)

**序列号seq**：占4个字节，用来标记数据段的顺序（用来保证报文的顺序发送），TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。

**确认号ack**：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。

**确认标志位ACK**：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效，ACK的值要么是0，要么是1。

**同步标志位SYN**：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。

**终止标志位FIN**：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接。

![捕获.PNG](https://i.loli.net/2019/12/19/mbey54SaVnfJv9G.png)

三次握手流程：

![捕获.PNG](https://i.loli.net/2019/12/19/d7TtCgGhubSL5mj.png)

seq是序列号，这是为了连接以后传送数据用的，ack是对收到的数据包的确认，值是等待接收的数据包的序列号。

>在第一次消息发送中，客户机随机选取一个序列号作为自己的初始序号发送给服务器；
>
>第二次消息时，服务器使用ack对客户机的数据包进行确认，因为已经收到了序列号为x的数据包，准备接收序列号为x+1的包，所以ack=x+1，同时服务器告诉客户机自己的初始序列号，就是seq=y；
>
>第三条消息时，客户机告诉服务器收到了服务器的确认消息并准备建立连接，客户机自己此条消息的序列号是x+1，所以seq=x+1，而ack=y+1是表示客户机正准备接收服务器序列号为y+1的数据包。

seq是数据包本身的序列号；ack是期望对方继续发送的那个数据包的序列号

四次挥手流程：

![捕获.PNG](https://i.loli.net/2019/12/19/awAIsHl2NLmgiYV.png)

>第一次挥手时，客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
>
>第二次挥手时，服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
>
>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
>
>第三次挥手时，服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
>
>第四次挥手时，客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
>
>最后，服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。



